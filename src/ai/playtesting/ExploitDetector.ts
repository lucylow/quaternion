/**
 * Exploit Detection System
 * 
 * Detects game exploits and vulnerabilities through adversarial testing:
 * - Resource loops (infinite resource generation)
 * - Edge case manipulation
 * - Mechanical combinations that break game balance
 * - Anomaly detection in game state transitions
 * 
 * Based on research from:
 * - Wilkins et al., "A Metric Learning Approach to Anomaly Detection in Video Games"
 * - Adversarial testing approaches from EA FIFA and Ubisoft systems
 */

import { PlaytestResult, BalanceIssue } from './PlaytestingAgent';
import { PlaytestingAgent } from './PlaytestingAgent';
import { PersonaType } from './ProceduralPersona';

export interface ExploitDetection {
  exploitType: 'resource_loop' | 'edge_case' | 'mechanical_break' | 'state_anomaly' | 'performance_issue';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  evidence: any;
  tick?: number;
  reproductionSteps?: string[];
}

export interface StateTransition {
  from: GameStateSnapshot;
  to: GameStateSnapshot;
  action: any;
  tick: number;
}

export interface GameStateSnapshot {
  tick: number;
  playerResources: Map<number, any>;
  unitCounts: Map<number, number>;
  buildingCounts: Map<number, number>;
  gameState: any;
}

/**
 * Exploit Detection System
 */
export class ExploitDetector {
  private stateTransitions: StateTransition[] = [];
  private anomalyThreshold: number = 0.7; // Threshold for anomaly detection
  private resourceHistory: Map<number, number[]> = new Map(); // Player -> resource values over time

  /**
   * Analyze playtest results for exploits
   */
  analyzeForExploits(results: PlaytestResult[]): ExploitDetection[] {
    const exploits: ExploitDetection[] = [];

    // 1. Resource loop detection
    exploits.push(...this.detectResourceLoops(results));

    // 2. Edge case detection
    exploits.push(...this.detectEdgeCases(results));

    // 3. Mechanical breaks
    exploits.push(...this.detectMechanicalBreaks(results));

    // 4. State anomalies
    exploits.push(...this.detectStateAnomalies(results));

    // 5. Performance issues
    exploits.push(...this.detectPerformanceIssues(results));

    return exploits;
  }

  /**
   * Record state transition for analysis
   */
  recordTransition(from: GameStateSnapshot, to: GameStateSnapshot, action: any, tick: number): void {
    this.stateTransitions.push({ from, to, action, tick });

    // Track resource history
    for (const [playerId, resources] of to.playerResources.entries()) {
      if (!this.resourceHistory.has(playerId)) {
        this.resourceHistory.set(playerId, []);
      }
      const totalResources = this.getTotalResources(resources);
      this.resourceHistory.get(playerId)!.push(totalResources);
    }
  }

  /**
   * Detect resource loops (infinite resource generation)
   */
  private detectResourceLoops(results: PlaytestResult[]): ExploitDetection[] {
    const exploits: ExploitDetection[] = [];

    for (const [playerId, resourceValues] of this.resourceHistory.entries()) {
      if (resourceValues.length < 10) continue;

      // Check for exponential growth (resource loop)
      const growthRates: number[] = [];
      for (let i = 1; i < resourceValues.length; i++) {
        if (resourceValues[i - 1] > 0) {
          const growthRate = (resourceValues[i] - resourceValues[i - 1]) / resourceValues[i - 1];
          growthRates.push(growthRate);
        }
      }

      // If growth rate is consistently high and increasing, it's a loop
      if (growthRates.length >= 5) {
        const avgGrowthRate = growthRates.reduce((a, b) => a + b, 0) / growthRates.length;
        const recentGrowthRate = growthRates.slice(-5).reduce((a, b) => a + b, 0) / 5;

        if (avgGrowthRate > 0.1 && recentGrowthRate > avgGrowthRate * 1.5) {
          exploits.push({
            exploitType: 'resource_loop',
            severity: 'critical',
            description: `Player ${playerId} shows exponential resource growth (possible infinite loop)`,
            evidence: {
              playerId,
              avgGrowthRate,
              recentGrowthRate,
              resourceValues: resourceValues.slice(-10)
            },
            reproductionSteps: [
              'Track resource generation rate',
              'Identify actions that trigger resource generation',
              'Check for circular dependencies in resource generation'
            ]
          });
        }
      }

      // Check for sudden resource spikes (exploit)
      for (let i = 1; i < resourceValues.length; i++) {
        const change = resourceValues[i] - resourceValues[i - 1];
        const previousValue = resourceValues[i - 1];
        
        if (previousValue > 0 && change > previousValue * 2) {
          // Resource doubled in one tick - likely exploit
          exploits.push({
            exploitType: 'resource_loop',
            severity: 'high',
            description: `Player ${playerId} resources spiked from ${previousValue} to ${resourceValues[i]} in one tick`,
            evidence: {
              playerId,
              from: previousValue,
              to: resourceValues[i],
              change,
              tick: i
            }
          });
        }
      }
    }

    return exploits;
  }

  /**
   * Detect edge cases (boundary conditions, null/undefined handling)
   */
  private detectEdgeCases(results: PlaytestResult[]): ExploitDetection[] {
    const exploits: ExploitDetection[] = [];

    for (const result of results) {
      // Check for actions at game boundaries
      const earlyActions = result.actions.filter(a => a.tick < 10);
      const lateActions = result.actions.filter(a => a.tick > result.duration - 10);

      // Check for actions with invalid states
      for (const action of result.actions) {
        if (action.action && action.action.cost !== undefined) {
          // Check if action was taken with insufficient resources
          // This would indicate a bug in resource validation
          if (action.score > 0.5 && action.action.cost > 0) {
            // Action was scored highly but might not be valid
            // This is a heuristic - actual validation would check game state
          }
        }
      }

      // Check for game ending in unexpected states
      if (result.outcome === 'timeout' && result.duration > 10000) {
        exploits.push({
          exploitType: 'edge_case',
          severity: 'medium',
          description: `Game timed out after ${result.duration} ticks (possible infinite loop or stuck state)`,
          evidence: {
            gameId: result.gameId,
            duration: result.duration,
            personaType: result.personaType
          }
        });
      }
    }

    return exploits;
  }

  /**
   * Detect mechanical breaks (combinations that break game balance)
   */
  private detectMechanicalBreaks(results: PlaytestResult[]): ExploitDetection[] {
    const exploits: ExploitDetection[] = [];

    // Analyze action sequences for problematic patterns
    for (const result of results) {
      const actionSequence = result.actions.map(a => a.action.type);
      
      // Detect rapid-fire building construction (possible exploit)
      const buildActions = result.actions.filter(a => 
        a.action.type === 'build_building' || a.action.type === 'build_unit'
      );
      
      if (buildActions.length > 0) {
        const buildIntervals: number[] = [];
        for (let i = 1; i < buildActions.length; i++) {
          buildIntervals.push(buildActions[i].tick - buildActions[i - 1].tick);
        }

        // If buildings are being built faster than resources allow
        const avgInterval = buildIntervals.reduce((a, b) => a + b, 0) / buildIntervals.length;
        if (avgInterval < 5 && buildActions.length > 5) {
          exploits.push({
            exploitType: 'mechanical_break',
            severity: 'high',
            description: `Rapid building construction detected (avg interval: ${avgInterval.toFixed(1)} ticks)`,
            evidence: {
              avgInterval,
              buildCount: buildActions.length,
              intervals: buildIntervals
            }
          });
        }
      }

      // Detect unit spam (possible exploit)
      const unitActions = result.actions.filter(a => a.action.type === 'build_unit');
      if (unitActions.length > 50) {
        const unitIntervals: number[] = [];
        for (let i = 1; i < unitActions.length; i++) {
          unitIntervals.push(unitActions[i].tick - unitActions[i - 1].tick);
        }
        const avgInterval = unitIntervals.reduce((a, b) => a + b, 0) / unitIntervals.length;
        
        if (avgInterval < 3) {
          exploits.push({
            exploitType: 'mechanical_break',
            severity: 'medium',
            description: `Unit spam detected: ${unitActions.length} units built with avg interval ${avgInterval.toFixed(1)} ticks`,
            evidence: {
              unitCount: unitActions.length,
              avgInterval
            }
          });
        }
      }
    }

    return exploits;
  }

  /**
   * Detect state anomalies (unexpected state transitions)
   */
  private detectStateAnomalies(results: PlaytestResult[]): ExploitDetection[] {
    const exploits: ExploitDetection[] = [];

    // Analyze state transitions for anomalies
    for (let i = 1; i < this.stateTransitions.length; i++) {
      const transition = this.stateTransitions[i];
      const prevTransition = this.stateTransitions[i - 1];

      // Check for impossible state changes
      const resourceChange = this.calculateResourceChange(
        transition.from.playerResources,
        transition.to.playerResources
      );

      // If resources decreased significantly without corresponding actions, it's an anomaly
      if (resourceChange < -0.5 && !this.hasResourceSpendingAction(transition.action)) {
        exploits.push({
          exploitType: 'state_anomaly',
          severity: 'medium',
          description: `Unexpected resource decrease at tick ${transition.tick}`,
          tick: transition.tick,
          evidence: {
            resourceChange,
            action: transition.action
          }
        });
      }

      // Check for unit count anomalies
      const unitCountChange = this.calculateUnitCountChange(
        transition.from.unitCounts,
        transition.to.unitCounts
      );

      // If units disappeared without combat, it's an anomaly
      if (unitCountChange < -5 && !this.hasCombatAction(transition.action)) {
        exploits.push({
          exploitType: 'state_anomaly',
          severity: 'high',
          description: `${Math.abs(unitCountChange)} units disappeared at tick ${transition.tick} without combat`,
          tick: transition.tick,
          evidence: {
            unitCountChange,
            action: transition.action
          }
        });
      }
    }

    return exploits;
  }

  /**
   * Detect performance issues
   */
  private detectPerformanceIssues(results: PlaytestResult[]): ExploitDetection[] {
    const exploits: ExploitDetection[] = [];

    // Check for games that take too long (performance issue)
    const longGames = results.filter(r => r.duration > 5000);
    if (longGames.length > 0) {
      const avgLongGameDuration = longGames.reduce((sum, r) => sum + r.duration, 0) / longGames.length;
      
      exploits.push({
        exploitType: 'performance_issue',
        severity: 'medium',
        description: `${longGames.length} games exceeded 5000 ticks (avg: ${avgLongGameDuration.toFixed(0)})`,
        evidence: {
          longGameCount: longGames.length,
          avgDuration: avgLongGameDuration
        }
      });
    }

    // Check for action spam (performance issue)
    for (const result of results) {
      if (result.actions.length > 1000) {
        exploits.push({
          exploitType: 'performance_issue',
          severity: 'low',
          description: `Game generated ${result.actions.length} actions (possible performance issue)`,
          evidence: {
            actionCount: result.actions.length,
            duration: result.duration
          }
        });
      }
    }

    return exploits;
  }

  /**
   * Helper methods
   */
  private getTotalResources(resources: any): number {
    if (typeof resources === 'object') {
      return (resources.ore || 0) + (resources.minerals || 0) + 
             (resources.energy || 0) + (resources.gas || 0) +
             (resources.biomass || 0) + (resources.data || 0);
    }
    return resources || 0;
  }

  private calculateResourceChange(from: Map<number, any>, to: Map<number, any>): number {
    let totalFrom = 0;
    let totalTo = 0;

    for (const resources of from.values()) {
      totalFrom += this.getTotalResources(resources);
    }

    for (const resources of to.values()) {
      totalTo += this.getTotalResources(resources);
    }

    if (totalFrom === 0) return 0;
    return (totalTo - totalFrom) / totalFrom;
  }

  private calculateUnitCountChange(from: Map<number, number>, to: Map<number, number>): number {
    let totalFrom = 0;
    let totalTo = 0;

    for (const count of from.values()) {
      totalFrom += count;
    }

    for (const count of to.values()) {
      totalTo += count;
    }

    return totalTo - totalFrom;
  }

  private hasResourceSpendingAction(action: any): boolean {
    if (!action) return false;
    return action.type === 'build_unit' || 
           action.type === 'build_building' || 
           action.type === 'research';
  }

  private hasCombatAction(action: any): boolean {
    if (!action) return false;
    return action.type === 'army_action' && action.action === 'attack';
  }
}

